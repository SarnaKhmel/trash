[[Вступ. Хуки]]

Перший, простий і найважливіший хук. З назви зрозуміло, що він пов'язаний з станом компонента. Саме завдяки йому у функціональних компонентів з'явився внутрішній стан.

```
import { useState } from "react";

const App = () => {

const [value, setValue] = useState(0);

return (

<div>

{" "}

{value}{" "}

<button type="button" onClick={() => setValue(value + 1)}>

{" "}

Increment value by 1{" "}

</button>{" "}

</div>

);

};
```

Виклик хука `useState` створює стан і метод, який змінюватиме його значення. У якості параметра хук приймає початковий стан, в нашому випадку число 0. У стані може зберігатися будь-який тип даних.

Хук `useState` повертає масив із двох елементів: перший - поточне значення стану, другий - функцію для його зміни, яку можна використовувати де завгодно, наприклад, в обробнику подій. React буде зберігати цей стан між рендерами. Використовуючи деструктуризацію, можна задати будь-які імена змінних.

ЩО Ж ТАКЕ ХУКИ?

**Хуки** - це просто функції, за допомогою яких можна «підчепитися» до стану та методів життєвого циклу з компонентів-функцій та використовувати React без класів.

## Відмінність із класами[​](https://textbook.edu.goit.global/react-zr7b4k/v1/uk/docs/lesson-07/use-state#%D0%B2%D1%96%D0%B4%D0%BC%D1%96%D0%BD%D0%BD%D1%96%D1%81%D1%82%D1%8C-%D1%96%D0%B7-%D0%BA%D0%BB%D0%B0%D1%81%D0%B0%D0%BC%D0%B8 "Пряме посилання на цей заголовок")

Функція оновлення стану схожа з `this.setState` у класах, але не зшиває новий і старий стан разом у разі якщо у стані зберігається об'єкт. У решті все як зі звичайним станом компонента. Основна відмінність: у класовому компоненті ми можемо створити лише один загальний стан, а у функціональному - скільки завгодно, і вони будуть незалежні один від одного.

```
// ❌ Поганоconst App = () => {  const [state, setState] = useState({    username: "",    todos: [{ text: "Learn hooks" }],    isModalOpen: false,  });};// ✅ Добреconst App = () => {  const [username, setUsername] = useState("");  const [todos, setTodos] = useState([{ text: "Learn hooks" }]);  const [isModalOpen, setIsModalOpen] = useState(false);};
```

КРАЩІ ПРАКТИКИ

Не зберігайте об'єкт з кількома непов'язаними властивостями. Краще зробити кілька незалежних станів та оновлювати їх атомарно, як у прикладі вище. Це не впливає на продуктивність.

## Обмеження хуків[​](https://textbook.edu.goit.global/react-zr7b4k/v1/uk/docs/lesson-07/use-state#%D0%BE%D0%B1%D0%BC%D0%B5%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F-%D1%85%D1%83%D0%BA%D1%96%D0%B2 "Пряме посилання на цей заголовок")

Будь-які хуки можна викликати лише на верхньому рівні компонента функції. Тобто, поза циклами, умовами, вкладеними функціями і т.п. Це означає, що хук або є в компоненті, або його немає. Такі, можливо, дивні обмеження стандартизують написання логіки компонента та роблять код менш заплутаним.

```
// ❌ Буде помилкаconst App = () => {  if (isLoggedIn) {    const [username, setUsername] = useState("");  }  // ...};// ✅ Так правильно використовувати хукиconst App = () => {  const [username, setUsername] = useState("");};
```

#react #hooks

[[Хук useEffect]]
